# UI/UX 컴포넌트 개발 방법

## 개요

Leaf 프론트엔드 플랫폼의 UI/UX 컴포넌트는 개발자가 좀 더 간편하게 비지니스 어플리케이션의 UI를 구성할 수 있도록 편의성의 극대화를 목표로 합니다.  
기존 UI/UX 컴포넌트의 경우 컴포넌트의 사용자 인터렉션을 위한 길고 복잡한 코드를 개발자가 직접 코딩을 해야 했지만, Leaf UI/UX 컴포넌트는 개발자는 순수한 비지니스 로직의 개발에만 집중할 수 있는 환경을 만들어 주고, 사용자 인터렉션은 서버에서 제공된 환경 설정 정보와 컴포넌트 자체의 설정 정보를 이용하여 자체적으로 처리될 수 있도록 하는 것을 목표로 합니다.

## 컴포넌트의 구분

Leaf 프론트엔드 UI/UX 컴포넌트는 크게 몇 가지 다른 측면에 따라 형태를 구분할 수 있습니다.

### 컴포넌트 구현 방식의 측면

* __Kendo-UI 기반의 래퍼 컴포넌트__
* __자체 구현 컴포넌트__

컴포넌트 구현 방식의 측면에서 봤을 때 Leaf 프론트엔드 컴포넌트는 상용컴포넌트를 활용하거나 래핑하는 컴포넌트인지 자체적으로 직접 개발한 컴포넌트인지에 따라서 구분할 수 있습니다.

Leaf 프론트엔드 컴포넌트는 기본적으로 Kendo-UI 컴포넌트를 기반으로 생성되게 되므로 대부분은 Kendo-UI 기반으니 래퍼 컴포넌트일 가능성이 높습니다.  
하지만, Kendo-UI 에서 제공하지 않는 기능이 필요하거나, 개발자가 어플리케이션의 UI 구조를 잡기 위해서 사용하게되는 레이아웃 컴포넌트의 경우에는 직접 구현이 필요하므로 자체 구현 컴포넌트가 됩니다.

### 컴포넌트의 역할에 따른 측면

* __레이아웃 컴포넌트__

  개발자가 업무 화면의 HTML 마크업를 작성한 후 그 화면의 레이아웃 구조를 사용자가 편리하게 사용할 수 있도록 하기 위해 CSS 코드나 스크립트 코드를 이용하여 업무 화면의 레이아웃을 잡아가는 반복적인 작업을 하나의 컴포넌트화 하여 개발자에게 제공하고 그 컴포넌트를 이용하면 약간의 마크업 코드로만 화면의 레이아웃이 완성될 수 있도록 하는 것이 레이아웃 컴포넌트입니다.  
  일반적으로 화면의 좌우 배치를 위한 CSS, 폼 입력을 위한 패널, 조회 조건 입력을 위한 패널, 탭, 스플리터 등의 요소들이 포함될 수 있습니다.

* __폼 컴포넌트__

  폼 컴포넌트는 사용자가 데이터를 입력할 수 있는 컴포넌트 요소들을 나타냅니다.  
  텍스트박스, 드롭다운리스트, 콤보, 체크박스, 라디오 등의 기본적인 입력 컴포넌트외에 숫자텍스트박스, 마스크텍스트박스 등의 확장 컴포넌트와 여러가지 컴포넌트가 하나의 컴포넌트를 구성하는 캘린더, 기간선택 등의 컴포넌트가 포함 될 수 있습니다.
  
* __데이터 컴포넌트__

  데이터 컴포넌트는 대용량의 데이터를 출력하기 위한 컴포넌트로 그리드, 리퍼터, 피벗그리드 등이 포함될 수 있으며, 가장 복잡한 컴포넌트이며 폼 컴포넌트와의 높은 결합도를 가지게 되므로 개발시 상당한 시간과 노력의 투여가 필요한 컴포넌트입니다.  
  데이터 컴포넌트는 UI를 가지는 컴포넌트와 그 UI 컴포넌트(그리드 등)에 데이터를 제공하는 데이터 제공자 역할을 하는 데이터소스로 구성합니다.  
  데이터소스는 데이터 컴포넌트 뿐만이 아니라 선택이 가능한 폼 컴포넌트(예, 드롭다운리스트, 콤보)등에도 데이터를 제공할 수 있습니다.
  
* __기타 컴포넌트__

  기타 컴포넌트는 위의 분류에 소속되지 못하는 컴포넌트들로 가장 대표적인 항목으로는 메시지박스가 될 수 있습니다.  
  이 분류에 속하는 컴포넌트는 위의 분류에 포함되지 못하는 컴포넌트의 집합이므로 공통 특징을 분류하기 힘들므로 공통 API 를 제공하기 위해 노력하지 않아도되며, 각 컴포넌트의 역할에 충실한 구현을 하면 됩니다.

## 컴포넌트의 상속 관계

### 컴포넌트의 기본 상속 관계 설정

위 컴포넌트의 역할에 따른 컴포넌트의 분류는 컴포넌트의 상속관계를 설정하는데 있어 가장 중요한 척도가 되는 부분입니다.  
컴포넌트간의 상속 관계를 설정하여 개발하는 이유는 각 컴포넌트 역할 분류별로 제공해야하는 기능이 정의되게 되며, 일반적으로 동일한 이름을 공유하게 됩니다.  
하지만, 실제 내부에서 처리되는 로직은 다를 수 밖에 없으므로 객체지향의 상속 관계 또는 인터페이스의 구현을 이용하므로서 사용자에게 일관적인 API 를 제공하고, 공통 처리 부분에 대한 일원화된 관리가 가능하게 됩니다.

* __`ComponentBase` 추상 클래스__

  모든 컴포넌트의 최상위 클래스로서 모든 컴포넌트는 이 추상 클래스를 상속 받습니다.  
  이 컴포넌트를 상속받고 있는 모든 클래스는 컴포넌트라는 것이 확정되므로 전체 컴포넌트에 대한 공통 처리가 필요하거나 객체가 컴포넌트인지 여부를 확인할때 사용할 수 있습니다.
  모든 컴포넌트가 구현해야하는 함수인 `initialize` 와 `setOptions` 를 추상 메서드 형태로 가지고 있어 모든 컴포넌트는 두가지 함수를 꼭 구현하도록 강제화 합니다.

* __`DOMComponent` 추상 클래스__

  업무 화면의 뷰 소스에 HTML 마크업 형태로 코딩되는 컴포넌트들의 최상위 클래스입니다. 
  `DOMComponent`는 대부분의 컴포넌트를 포함하지만, 메시지박스 나 데이터소스와 같이 뷰의 HTML 마크업 소스 상에 포함되지 않는 요소들을 포함되지 않습니다.
  `DOMComponent`는 `ComponentBase` 클래스를 상속받습니다.
  이 클래스에는 DOM 요소의 생성 및 핸들링에 필요한 `$element` 및 `$container` 속성과 마크업 코드에 선언된 옵션 정보를 파싱하기 위한 `parseOptions` 함수를 추상 메서드로 가지게 됩니다.
  
* __`FormComponent` 추상 클래스__

  `FormComponent`는 위의 컴포넌트의 역할에 따른 구분에서의 폼 컴포넌트에 해당하는 항목입니다.
  사용자가 데이터를 입력하는 용도로 사용하는 모든 컴포넌트가 소속되게 되며, 상속받는 컴포넌트들에서 필요한 공통 API 를 추상 메서드나 콘크리트 메서드 형태로 공통화 시켜 발전시켜 나갑니다.  
  대부분의 폼 컴포넌트는 Kendo-UI 컴포넌트를 활용하므로 모든 컴포넌트에서 빠짐없이 공통으로 나타나는 함수나 이벤트 속성등을 등록하여 관리합니다.
  

### 추가 상속 관계의 설정

컴포넌트를 개발하다보면 각 컴포넌트들이 다양한 연관 관계를 가지게 되고 같거나 비슷한 기능들을 공유하게 됩니다.  
이럴 때 각 컴포넌트 간에 상속 관계를 이용하여 조직화 할 수 있습니다.
하지만, 상속 관계를 계속적으로 늘여나가다 보면 상속 관계 자체가 추후 확장성을 저해하는 원인이 되기도 합니다.
상속 관계를 이용하여 컴포넌트를 조직화 하다보면 다양한 한계에 봉착하게 됩니다.  
가장 대표적인 한계가 특징적인 면에서는 API 의 공유가 가능하지만 내부 로직이 상당 부분 달라서 상속 관계를 사용하는 이점이 희미해 지는 때라던가 특징을 공유하는 컴포넌트의 수가 적어 상속 관계의 설정에서 얻을 수 있는 이점이 현저히 떨어지는 경우등이 있을 수 있습니다.  

이런 상황에서는 상속 관계를 고집하지 말고 주제가 기능별로 인터페이스를 선언하고 그 인터페이스를 이용하여 컴포지션(Composition) 관계를 이용하여 코딩하는 것이 좋습니다.

예를 들어 폼 컴포넌트 중 포커스 이동에 관한 기능을 선언한다고 하였을 때 `IFocusable` 인터페이스를 선언하고 그 인터페이스의 실제 구현체를 만든 후 공유할 클래스에서는 그 구현체를 내부에서 이용하는 방식으로 활용할 수 있습니다.

아래 예를 참고하십시오.

```TypeScript
// 추상화된 기능을 수행할 인터페이스
interface IFocusable {
    get canFocus(): boolean;
    setFocus(): void;
    nextFocus(): void;
}

// 인터페이스의 실제 동작을 구현하는 구현체 클래스
class FormComponentFocusManager implements IFocusable {
    
    ....
    
    constructor(element: FormComponent, container: DOMComponent) {
        this.element = element;
        this.container = container;
    }
    
    get canFocus(): boolean {
        return !(this.element.isDisabled() || this.element.isReadonly());
    }
    
    setFocus(): void {
        if (this.canFocus) {
            this.$element.focus();
        }        
    }
    
    nextFocus(): void {
        let next = this.getNextFocusableComponent();
        
        next.setFocus();
    }
    
    ....
}

// 포커스에 대한 같은 동작을 수행하는 첫 번째 컴포넌트 
class MyFormComponent1 extend FormComponent implement IFocusable, IDoSomething {

    ....
    
    private _focusManager: IFocusable;
    
    constructor() {
        super();
        this._focusManager = new FormComponentFocusManager(this.$element, this.$container);
    }
    
    get canFocus(): boolean {
        return this._focusManager.canFocus();
    }
    
    setFocus(): void {
        return this._focusManager.setFocus();
    }
    
    nextFocus(): void {
        return this._focusManager.nextFocus();
    }
}

// 포커스에 대한 같은 동작을 수행하는 두 번째 컴포넌트
class MyFormComponent2 extend FormComponent implement IFocusable, IDoAnything {

    ....
    
    private _focusManager: IFocusable;
    
    constructor() {
        super();
        this._focusManager = new FormComponentFocusManager(this.$element, this.$container);
    }
    
    get canFocus(): boolean {
        return this._focusManager.canFocus();
    }
    
    setFocus(): void {
        return this._focusManager.setFocus();
    }
    
    nextFocus(): void {
        return this._focusManager.nextFocus();
    }
}
```

위의 예제에서는 같은 포커스 처리를 공유하는 컴포넌트가 하나의 인터페이스 구현체를 내부 멤버로 가지고 그 구현체가 `IFocusable` 인터페이스의 구현을 대리함으로서 두가지 컴포넌트는 같은 방식의 행위를 보장 받을 수 있으며, 처리 로직의 변화가 일어났을때는 인터페이스의 구현체만 수정하면 두가지 컴포넌트의 수정 없이 같은 동작을 보장할 수 있게 됩니다.

상위 클래스의 추상 메서드를 사용할 수도 있겠지만, 추상 메서드는 모든 자식 클래스마다 구현을 강제화 하므로 결론적으로는 위와 동일한 형태가 됩니다.

인터페이스를 이용했을 때의 이점은 하나의 클래스는 여러 개의 인터페이스를 함께 구현할 수 있으므로 기능별 구분된 다양한 인터페이스를 함께 구현함으로서 컴포넌트의 분류별로 다른 기능들을 구현할 수 있게됩니다.
위 예 에서는 두 컴포넌트 클래스가 `IFocusable` 인터페이스로 구현하는 기능은 공유하지만, `IDoSomething` 과 `IDoAnything` 인터페이스는 각기 구현하므로 각각 다른 기능을 구현할 수 있므려, 추후 `IDoSomething`과 `IDoAnything` 인터페이스를 구현하는 컴포넌트 별로 형식을 추가적으로 확장할 수 있는 방법을 손에 넣게 됩니다.
