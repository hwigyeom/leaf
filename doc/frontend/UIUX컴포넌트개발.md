# UI/UX 컴포넌트 개발 방법

## 개요

Leaf 프론트엔드 플랫폼의 UI/UX 컴포넌트는 개발자가 좀 더 간편하게 비지니스 어플리케이션의 UI를 구성할 수 있도록 편의성의 극대화를 목표로 합니다.  
기존 UI/UX 컴포넌트의 경우 컴포넌트의 사용자 인터렉션을 위한 길고 복잡한 코드를 개발자가 직접 코딩을 해야 했지만, Leaf UI/UX 컴포넌트는 개발자는 순수한 비지니스 로직의 개발에만 집중할 수 있는 환경을 만들어 주고, 사용자 인터렉션은 서버에서 제공된 환경 설정 정보와 컴포넌트 자체의 설정 정보를 이용하여 자체적으로 처리될 수 있도록 하는 것을 목표로 합니다.

## 컴포넌트의 구분

Leaf 프론트엔드 UI/UX 컴포넌트는 크게 몇 가지 다른 측면에 따라 형태를 구분할 수 있습니다.

### 컴포넌트 구현 방식의 측면

* __Kendo UI 기반의 래퍼 컴포넌트__
* __자체 구현 컴포넌트__

컴포넌트 구현 방식의 측면에서 봤을 때 Leaf 프론트엔드 컴포넌트는 상용컴포넌트를 활용하거나 래핑하는 컴포넌트인지 자체적으로 직접 개발한 컴포넌트인지에 따라서 구분할 수 있습니다.

Leaf 프론트엔드 컴포넌트는 기본적으로 Kendo-UI 컴포넌트를 기반으로 생성되게 되므로 대부분은 Kendo-UI 기반으니 래퍼 컴포넌트일 가능성이 높습니다.  
하지만, Kendo-UI 에서 제공하지 않는 기능이 필요하거나, 개발자가 어플리케이션의 UI 구조를 잡기 위해서 사용하게되는 레이아웃 컴포넌트의 경우에는 직접 구현이 필요하므로 자체 구현 컴포넌트가 됩니다.

### 컴포넌트의 역할에 따른 측면

* __레이아웃 컴포넌트__

  개발자가 업무 화면의 HTML 마크업를 작성한 후 그 화면의 레이아웃 구조를 사용자가 편리하게 사용할 수 있도록 하기 위해 CSS 코드나 스크립트 코드를 이용하여 업무 화면의 레이아웃을 잡아가는 반복적인 작업을 하나의 컴포넌트화 하여 개발자에게 제공하고 그 컴포넌트를 이용하면 약간의 마크업 코드로만 화면의 레이아웃이 완성될 수 있도록 하는 것이 레이아웃 컴포넌트입니다.  
  일반적으로 화면의 좌우 배치를 위한 CSS, 폼 입력을 위한 패널, 조회 조건 입력을 위한 패널, 탭, 스플리터 등의 요소들이 포함될 수 있습니다.

* __폼 컴포넌트__

  폼 컴포넌트는 사용자가 데이터를 입력할 수 있는 컴포넌트 요소들을 나타냅니다.  
  텍스트박스, 드롭다운리스트, 콤보, 체크박스, 라디오 등의 기본적인 입력 컴포넌트외에 숫자텍스트박스, 마스크텍스트박스 등의 확장 컴포넌트와 여러가지 컴포넌트가 하나의 컴포넌트를 구성하는 캘린더, 기간선택 등의 컴포넌트가 포함 될 수 있습니다.
  
* __데이터 컴포넌트__

  데이터 컴포넌트는 대용량의 데이터를 출력하기 위한 컴포넌트로 그리드, 리퍼터, 피벗그리드 등이 포함될 수 있으며, 가장 복잡한 컴포넌트이며 폼 컴포넌트와의 높은 결합도를 가지게 되므로 개발시 상당한 시간과 노력의 투여가 필요한 컴포넌트입니다.  
  데이터 컴포넌트는 UI를 가지는 컴포넌트와 그 UI 컴포넌트(그리드 등)에 데이터를 제공하는 데이터 제공자 역할을 하는 데이터소스로 구성합니다.  
  데이터소스는 데이터 컴포넌트 뿐만이 아니라 선택이 가능한 폼 컴포넌트(예, 드롭다운리스트, 콤보)등에도 데이터를 제공할 수 있습니다.
  
* __기타 컴포넌트__

  기타 컴포넌트는 위의 분류에 소속되지 못하는 컴포넌트들로 가장 대표적인 항목으로는 메시지박스가 될 수 있습니다.  
  이 분류에 속하는 컴포넌트는 위의 분류에 포함되지 못하는 컴포넌트의 집합이므로 공통 특징을 분류하기 힘들므로 공통 API 를 제공하기 위해 노력하지 않아도되며, 각 컴포넌트의 역할에 충실한 구현을 하면 됩니다.

## 컴포넌트의 상속 관계

### 컴포넌트의 기본 상속 관계 설정

위 컴포넌트의 역할에 따른 컴포넌트의 분류는 컴포넌트의 상속관계를 설정하는데 있어 가장 중요한 척도가 되는 부분입니다.  
컴포넌트간의 상속 관계를 설정하여 개발하는 이유는 각 컴포넌트 역할 분류별로 제공해야하는 기능이 정의되게 되며, 일반적으로 동일한 이름을 공유하게 됩니다.  
하지만, 실제 내부에서 처리되는 로직은 다를 수 밖에 없으므로 객체지향의 상속 관계 또는 인터페이스의 구현을 이용하므로서 사용자에게 일관적인 API 를 제공하고, 공통 처리 부분에 대한 일원화된 관리가 가능하게 됩니다.

* __`ComponentBase` 추상 클래스__

  모든 컴포넌트의 최상위 클래스로서 모든 컴포넌트는 이 추상 클래스를 상속 받습니다.  
  이 컴포넌트를 상속받고 있는 모든 클래스는 컴포넌트라는 것이 확정되므로 전체 컴포넌트에 대한 공통 처리가 필요하거나 객체가 컴포넌트인지 여부를 확인할때 사용할 수 있습니다.
  모든 컴포넌트가 구현해야하는 함수인 `initialize` 와 `setOptions` 를 추상 메서드 형태로 가지고 있어 모든 컴포넌트는 두가지 함수를 꼭 구현하도록 강제화 합니다.

* __`DOMComponent` 추상 클래스__

  업무 화면의 뷰 소스에 HTML 마크업 형태로 코딩되는 컴포넌트들의 최상위 클래스입니다. 
  `DOMComponent`는 대부분의 컴포넌트를 포함하지만, 메시지박스 나 데이터소스와 같이 뷰의 HTML 마크업 소스 상에 포함되지 않는 요소들을 포함되지 않습니다.
  `DOMComponent`는 `ComponentBase` 클래스를 상속받습니다.
  이 클래스에는 DOM 요소의 생성 및 핸들링에 필요한 `$element` 및 `$container` 속성과 마크업 코드에 선언된 옵션 정보를 파싱하기 위한 `parseOptions` 함수를 추상 메서드로 가지게 됩니다.
  
* __`FormComponent` 추상 클래스__

  `FormComponent`는 위의 컴포넌트의 역할에 따른 구분에서의 폼 컴포넌트에 해당하는 항목입니다.
  사용자가 데이터를 입력하는 용도로 사용하는 모든 컴포넌트가 소속되게 되며, 상속받는 컴포넌트들에서 필요한 공통 API 를 추상 메서드나 콘크리트 메서드 형태로 공통화 시켜 발전시켜 나갑니다.  
  대부분의 폼 컴포넌트는 Kendo-UI 컴포넌트를 활용하므로 모든 컴포넌트에서 빠짐없이 공통으로 나타나는 함수나 이벤트 속성등을 등록하여 관리합니다.
  

### 추가 상속 관계의 설정

컴포넌트를 개발하다보면 각 컴포넌트들이 다양한 연관 관계를 가지게 되고 같거나 비슷한 기능들을 공유하게 됩니다.  
이럴 때 각 컴포넌트 간에 상속 관계를 이용하여 조직화 할 수 있습니다.
하지만, 상속 관계를 계속적으로 늘여나가다 보면 상속 관계 자체가 추후 확장성을 저해하는 원인이 되기도 합니다.
상속 관계를 이용하여 컴포넌트를 조직화 하다보면 다양한 한계에 봉착하게 됩니다.  
가장 대표적인 한계가 특징적인 면에서는 API 의 공유가 가능하지만 내부 로직이 상당 부분 달라서 상속 관계를 사용하는 이점이 희미해 지는 때라던가 특징을 공유하는 컴포넌트의 수가 적어 상속 관계의 설정에서 얻을 수 있는 이점이 현저히 떨어지는 경우등이 있을 수 있습니다.  

이런 상황에서는 상속 관계를 고집하지 말고 주제가 기능별로 인터페이스를 선언하고 그 인터페이스를 이용하여 컴포지션(Composition) 관계를 이용하여 코딩하는 것이 좋습니다.

예를 들어 폼 컴포넌트 중 포커스 이동에 관한 기능을 선언한다고 하였을 때 `IFocusable` 인터페이스를 선언하고 그 인터페이스의 실제 구현체를 만든 후 공유할 클래스에서는 그 구현체를 내부에서 이용하는 방식으로 활용할 수 있습니다.

아래 예를 참고하십시오.

```TypeScript
// 추상화된 기능을 수행할 인터페이스
interface IFocusable {
    get canFocus(): boolean;
    setFocus(): void;
    nextFocus(): void;
}

// 인터페이스의 실제 동작을 구현하는 구현체 클래스
class FormComponentFocusManager implements IFocusable {
    
    ....
    
    constructor(element: FormComponent, container: DOMComponent) {
        this.element = element;
        this.container = container;
    }
    
    get canFocus(): boolean {
        return !(this.element.isDisabled() || this.element.isReadonly());
    }
    
    setFocus(): void {
        if (this.canFocus) {
            this.$element.focus();
        }        
    }
    
    nextFocus(): void {
        let next = this.getNextFocusableComponent();
        
        next.setFocus();
    }
    
    ....
}

// 포커스에 대한 같은 동작을 수행하는 첫 번째 컴포넌트 
class MyFormComponent1 extend FormComponent implement IFocusable, IDoSomething {

    ....
    
    private _focusManager: IFocusable;
    
    constructor() {
        super();
        this._focusManager = new FormComponentFocusManager(this.$element, this.$container);
    }
    
    get canFocus(): boolean {
        return this._focusManager.canFocus();
    }
    
    setFocus(): void {
        return this._focusManager.setFocus();
    }
    
    nextFocus(): void {
        return this._focusManager.nextFocus();
    }
}

// 포커스에 대한 같은 동작을 수행하는 두 번째 컴포넌트
class MyFormComponent2 extend FormComponent implement IFocusable, IDoAnything {

    ....
    
    private _focusManager: IFocusable;
    
    constructor() {
        super();
        this._focusManager = new FormComponentFocusManager(this.$element, this.$container);
    }
    
    get canFocus(): boolean {
        return this._focusManager.canFocus();
    }
    
    setFocus(): void {
        return this._focusManager.setFocus();
    }
    
    nextFocus(): void {
        return this._focusManager.nextFocus();
    }
}
```

위의 예제에서는 같은 포커스 처리를 공유하는 컴포넌트가 하나의 인터페이스 구현체를 내부 멤버로 가지고 그 구현체가 `IFocusable` 인터페이스의 구현을 대리함으로서 두가지 컴포넌트는 같은 방식의 행위를 보장 받을 수 있으며, 처리 로직의 변화가 일어났을때는 인터페이스의 구현체만 수정하면 두가지 컴포넌트의 수정 없이 같은 동작을 보장할 수 있게 됩니다.

상위 클래스의 추상 메서드를 사용할 수도 있겠지만, 추상 메서드는 모든 자식 클래스마다 구현을 강제화 하므로 결론적으로는 위와 동일한 형태가 됩니다.

인터페이스를 이용했을 때의 이점은 하나의 클래스는 여러 개의 인터페이스를 함께 구현할 수 있으므로 기능별 구분된 다양한 인터페이스를 함께 구현함으로서 컴포넌트의 분류별로 다른 기능들을 구현할 수 있게됩니다.
위 예 에서는 두 컴포넌트 클래스가 `IFocusable` 인터페이스로 구현하는 기능은 공유하지만, `IDoSomething` 과 `IDoAnything` 인터페이스는 각기 구현하므로 각각 다른 기능을 구현할 수 있으며, 추후 `IDoSomething`과 `IDoAnything` 인터페이스를 구현하는 컴포넌트를 그룹화하여 처리하는 방법을 손에 넣게 됩니다.


## 컴포넌트의 생성 옵션

모든 컴포넌트는 컴포넌트가 생성 될때 자신의 생성 규칙을 제공받기 위해 초기화 옵션을 필요로 합니다.  
UI 생김새를 결정한다던지 기본 설정값을 설정한다던지 동작방식을 기본 방식과는 다르게 동작하도록 한다던지 초기화 옵션에 따라서 컴포넌트 다양하게 변화할 수 있습니다.

이러한 옵션 설정 값 덕분에 컴포넌트는 더욱 강력한 기능을 가지게 되고 사용자 및 개발자의 요구사항에 좀 더 유연하게 대응할 수 있게 됩니다.

Leaf 프론트엔드 컴포넌트들은 거의 대부분 기본적으로 초기화 옵션을 받아들이게 됩니다.

### `IComponentOptions` 인터페이스

위에서 설명했다시피 컴포넌트들은 컴포넌트에서 필요로 하는 여러가지 옵션을 받아들이게 됩니다.
기본 값이 정해져 있어 생략해도 무방한 옵션이 있는 반면 꼭 설정을 해야만 동작하는 옵션도 존재합니다.
받아 들일 수 있는 형식도 기본 형식은 `boolean` 값과 JSON 형태의 `object`를 취사 선택하여 제공할 수 있는 옵션도 존재할 수 있습니다.

Leaf 프론트엔드 플랫폼에서는 이러한 다양한 형태로 변화되는 컴포넌트 생성 옵션을 하나의 형식으로 관리하기 위해서 아무런 멤버도 존재하지 않는 `IComponentOptions` 인터페이스를 제공합니다.

타입스크립트에서의 인터페이스는 자바스크립트 컴파일 시에 아무런 형식 정보도 전달되지 않으므로, 타입스크립트에서 인터페이스를 선언하였다고하여 그 인터페이스 형식 정보가 실제 동작하는 자바스크립트에는 형식적인 강제성을 가지지 못합니다.

그럼에도 인터페이스를 정의하여 사용하는 이유는 타입스크립트를 이용하여 개발 시 개발툴의 도움을 받아서 형식에 대한 인텔리센스 기능을 사용할 수 있도록 해줄뿐만 아니라 가장 중요한 컴파일 시에 잘못된 형식의 값이 전달 되었을 때 컴파일러에서 오류가 발생하여 좀 더 신뢰도 높은 코드의 생산을 강제화 할 수 있기 때문입니다.

#### 각 컴포넌트 별 옵션의 정의

위에서 말한 바와 같이 `IComponentOptions` 는 멤버가 존재하지 않는 인터페이스입니다.
하지만 인터페이스는 클래스간의 상속 관계와 유사하게 `extends` 키워드를 통해 확장이 가능합니다.
Leaf 프론트엔드 컴포넌트들은 이를 이용하여 컴포넌트 별 옵션을 정의합니다.

각 컴포넌트의 추상화된 API에서 최상위 인터페이스인 `IComponentOptions` 인터페이스로 형식을 강제한다면 그 하위 컴포넌트에 `IComponentOptions` 인터페이스를 확장하지 않은 형식을 전달하고자 하면 컴파일러에서 오류가 발생할 것 입니다. 

이런 방식으로 업무 개발자가 제어되지 않는 형식의 값을 전달할 수 없도록 강제할 수 있습니다.

그럼 각 컴포넌트의 옵션을 정의하는 방법을 예로 보겠습니다.

```TypeScript
interface IComponentOptions {
}

interface ICheckboxOptions extends IComponentOptions {
    id: string;
    label?: string;
    checked?: boolean;
}

abstract class FormComponent {
    ...
    abstract setOptions(options: IComponentOptions): void;
}

class Checkbox extends FormComponent {
    private _options: ICheckboxOptions;
    ...
    
    setOptions(options: ICheckboxOptions): void {
        this._options = options;
    }
}
```

위 예제에서 보면 최상위 클래스인 `FormComponent` 클래스에서는 추상 메서드인 `setOptions` 에서 `IComponentOptions` 인터페이스를 매개변수 형식으로 가지지만 실제 구현 클래스인 `Checkbox` 클래스에서는 `IComponentOptions` 를 확장한 `ICheckboxOptions` 인터페이스를 매개변수 형식으로 가지게 됩니다.  
이는 두 형식이 확장 관계에 있기 때문에 컴파일러에서 오류를 발생시키지 않게 됩니다.

이런 방식으로 모든 컴포넌트를 공통으로 처리하는 클래스에서는 최상위에 추상화되어 있는 형식을 이용하고 개별 구현 클래스에서는 자신에게 필요한 확장된 인터페이스를 활용하므로서 유연한 코드를 가능하게 합니다.

만일 위의 코드를 이용하여 개발을 하는 코드에서 `Checkbox` 클래스의 `setOptions` 함수에다 `ICheckboxOptions` 인터페이스의 정의와 맞지 않는 JSON 형식의 `Object`를 전달하였을 경우에는 타입스크립트의 컴파일러가 오류를 발생시키므로 컴포넌트를 이용하는 개발자의 코드의 신뢰도를 크게 향상시킬 수가 있습니다.

## Kendo UI 기반의 래퍼 컴포넌트 개발 방법

Kendo-UI 기반의 컴포넌트를 작성할 때의 유의할 점은 Kendo-UI 컴포넌트를 그대로 노출시키는 것을 자제해야만 한다는 점입니다.  
추후 발생할 수 있는 컴포넌트의 기능 수정 및 확장 커스터마이징에 대한 가능성의 확보를 위해서라도 Kendo-UI 컴포넌트의 인스턴스는 은닉화(Encapsulation) 처리를 하고 자체적으로 정의된 API에서 Kendo-UI 컴포넌트의 인스턴스를 제어하는 방식으로 개발을 하는 것이 좋습니다.

물론 각각의 컴포넌트에 따라 상황이 다를 수 있겠으나, 일반적으로 개발이 완료된 시점부터 지속적으로 들어오는 변경 요청사항을 대응하기 위해서는 Kendo-UI 컴포넌트의 내부 로직을 런타임에 교체하거나 확장하는 방향으로 수정이 가해질 가능성이 높으므로 최초 접근 시 부터 은닉화에 신경을 써서 개발을 수행하여야 합니다.


### Kendo UI API Documentation

Kendo UI 컴포넌트에 대한 상세한 API 및 설정 옵션 정보는 Kendo UI Documentation 사이트에서 확인할 수 있습니다.

* Kendo UI Documentation : https://docs.telerik.com/kendo-ui/introduction

위 사이트에 접속 후 `API Reference` 메뉴를 열고 `JavaScript` 폴더를 확장하면 Kendo UI 관련 상세한 API 설명이 제공됩니다.  
일반적인 UI 컴포넌트는 `ui` 폴더에 존재하며 `DataSource`와 같이 데이터 관련 컴포넌트는 `data` 폴더 내에 존재합니다.

컴포넌트의 이름를 클릭하면 우측에 Kendo UI 컴포넌트에서 제공하는 API 목록이 출력되며, 일반적으로 제공되는 API 의 분류는 아래와 같습니다.

* __컴포넌트 설정 옵션 (Configuration)__
* __필드 (Fields)__
* __메서드 (Methods)__
* __이벤트 (Events)__

Leaf 프론트엔드 래퍼 또는 확장 컴포넌트 클래스에서 제공하게될 API 의 분류도 위와 크게 다르지 않으므로 대부분은 동일하게 노출 되겠지만 jQuery 기반으로 작성된 Kendo UI 컴포넌트와는 다르게 Leaf 프론트엔드 UI/UX 컴포넌트는 TypeScript 기반의 Strong-Typed API 를 지향하므로 함수 대신 형식을 지정한 getter, setter 속성을 사용하는 등 달라져야 하는 부분도 상당 수 존재합니다.

